### 2) Detecting new behaviors
---
<!-- 
The fuzzer maintains a global map of tuples seen in previous executions; this data can be rapidly compared with individual traces and updated in just a couple of dword- or qword-wide instructions and a simple loop. 
-->

퍼저는 이전에 실행에서 확인 된 튜플의 글로벌 맵을 포함하고있다. 튜블의 글로벌 맵(데이터)은 individual traces들이랑 빠르게 비교되고 dword나 qword-wide로 되어 있는 instruction들과 간단한 loop로 업데이트될 수 있습니다.

<!-- 
When a mutated input produces an execution trace containing new tuples, the corresponding input file is preserved and routed for additional processing later on (see section #3). 
-->

mutated input은 새로운 튜플을 포함하고 있는 execution trace를 만들고 그 인풋을 담고 있는 인풋파일은 보존되고, 나중에 추가적인 실행을 위해 쓰입니다. (섹션 #3을 보자.)

<!-- 
Inputs that do not trigger new local-scale state transitions in the execution trace (i.e., produce no new tuples) are discarded, even if their overall control flow sequence is unique. 
-->

Execution trace에서의 Local-scale 상태 전환을 새롭게 찾지 못하는(새로운 튜플을 생성하지 못하는) 인풋들은 다 버립니다. 아무리 Control flow sequence가 고유하더라도 말이죠.

<!-- 
This approach allows for a very fine-grained and long-term exploration of program state while not having to perform any computationally intensive and fragile global comparisons of complex execution traces, and while avoiding the scourge of path explosion. 
-->

이 방법을 사용하면 계산적으로 복잡하고 귀찮은 비교들을 수행할 필요도 없고, 경로가 터져 버리는 재앙없이 세밀하고 긴 탐구가 가능합니다.

<!-- 
To illustrate the properties of the algorithm, consider that the second trace shown below would be considered substantially new because of the presence of new tuples (CA, AE):

#1: A -> B -> C -> D -> E
#2: A -> B -> C -> A -> E
-->

한번 알고리즘의 속성을 이해해봅시다. 아래에서 두번째에 있는 trace는 새로운 튜플인 CA, AE가 있으니까 사실상 새로운 것일 가능성이 큽니다.
```
#1: A -> B -> C -> D -> E
#2: A -> B -> C -> A -> E
```

<!-- 
At the same time, with #2 processed, the following pattern will not be seen as unique, despite having a markedly different overall execution path: 

#3: A -> B -> C -> A -> B -> C -> A -> B -> C -> D -> E

-->

#2가 실행될때, 따라나오는 패턴인 요 밑에 있는 #3를 살펴보면 이 패턴이 뭔가 고유한거 같지는 않아도, 분명히 전체적으로 다른 execution path를 가지고 있는것을 확인할 수 있습니다.
```
#3: A -> B -> C -> A -> B -> C -> A -> B -> C -> D -> E
```

<!-- 
In addition to detecting new tuples, the fuzzer also considers coarse tuple hit counts. These are divided into several buckets: 

1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+
-->

새로운 튜플들을 탐지하는거 말고도, 퍼저는 항상 튜플 적중 횟수를 고려해야합니다. 요것들은 여러 Buckets로 나뉩니다. :
```
1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+
```

<!-- 
To some extent, the number of buckets is an implementation artifact: it allows an in-place mapping of an 8-bit counter generated by the instrumentation to an 8-position bitmap relied on by the fuzzer executable to keep track of the already-seen execution counts for each tuple. 
-->

어느정도 까지, Buckets들의 개수는 Implementation Artifact 입니다. 이것을 이용하면 8비트 카운터의 In-place mapping이 가능합니다. 여기서 8비트 카운터는 8-position Bitmap에 의한 Instrumentation에 의해서 생성됩니다. 또한, 8-position Bitmap은 각 튜플에 대하여 이미 확인한 실행 횟수들을 지속적으로 추적(track)을 하기 위해 퍼저에 의존합니다.

<!-- 
Changes within the range of a single bucket are ignored; transition from one bucket to another is flagged as an interesting change in program control flow, and is routed to the evolutionary process outlined in the section below. 
-->

오로지 하나의 Bucket의 범위에서 나온 변화들은 다 무시됩니다. 즉, 한 Bucket에서 다른 Bucket으로의 변화를 Program control flow에서의 Interesting 한 변화로 취급합니다. 그리고 이런 Interesting한 변화들은 아래 섹션에 나와있는 Evolutinary process로 연결됩니다.

<!-- 
The hit count behavior provides a way to distinguish between potentially interesting control flow changes, such as a block of code being executed twice when it was normally hit only once.  
-->

Hit count behavior는 잠재적으로 Interesting 할지도 모르는 컨트롤 플로우 변화를 구분하는 방법을 알려줍니다. 예를 들어서 코드의 블록을 딱 한번 hit했는데 두번 실행되는 경우는 흥미로운 컨트롤 플로우 변화에 해당합니다.

<!-- 
At the same time, it is fairly insensitive to empirically less notable changes, such as a loop going from 47 cycles to 48. The counters also provide some degree of "accidental" immunity against tuple collisions in dense trace maps.
 -->

동시에, 덜 중요해보이는 변화에는 상당히 둔감하게 반응합니다. 예를들어 경험적으로, 루프가 47cycles에서 48로 변화하는것은 관심이 없습니다. 또, 그 카운터들은 조밀한 trace maps에서 튜플 충돌에 대해 어느정도 "우연한" 면역을 줄때가 있습니다. (카운터들은 가끔가다 우연히 튜플 충돌 터져도 문제 없이 지켜줄때가 있습니다.)

<!-- 
The execution is policed fairly heavily through memory and execution time limits; by default, the timeout is set at 5x the initially-calibrated
execution speed, rounded up to 20 ms. The aggressive timeouts are meant to prevent dramatic fuzzer performance degradation by descending into tarpits that, say, improve coverage by 1% while being 100x slower; we pragmatically reject them and hope that the fuzzer will find a less expensive way to reach the same code. Empirical testing strongly suggests that more generous time limits are not worth the cost. 
-->

실행은 메모리와 실행 시간 제한에 의해서 상당히 엄격하게 감시됩니다. 기본적으로 타임아웃은 초기 보정된 실행 속도의 5배인 약 20m/s로 설정됩니다. 공격적인 타임아웃은 극적인(Dramatic) 퍼저 성능 저하를 방지하는 것을 의미합니다. 극적인 퍼저 성능저하는 Tarpits로의 하강에 의해 발생하는데, 이게 뭔 뜻이냐면 coverage를 1%개선하는데 100배 느려지는 것을 의미합니다. 우리는 실용적으로 이 방법들을 거부하고 퍼저가 적은 비용으로도 같은 코드에 도달할 수 있는 방법을 찾기를 바랍니다. 그동안 진행했던 테스트들은 너무 많이 시간제한을 두는 것은 투자대비 가치가 없다는 것을 알려주고 있습니다. (소용이 없다는 것을 강력하게 알려주고 있습니다.)